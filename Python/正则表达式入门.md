# 正则表达式

正则表达式（Regular Expression)是强大的、便捷、高效的文本处理工具,是用于匹配字符串中字符组合的模式.

## 正则表达式基础（依据`Perl`）

- 匹配单个字符的元字符

|元字符||匹配对象|
|------|------|----|  
|`.`|点号|匹配单个任意字符|
|`[...]`|字符组|匹配单个列出的字符|
|`[^...]`|排除型字符组|匹配单个未列出的字符|
|`\char`|转义字符|若`char`是元字符，或转义字符无特殊含义时，匹配`char`对应的普通字符|

- 提供计数功能的元字符

|元字符||匹配对象|
|------|------|----|
|`?`|问号|允许匹配一次，但非必须|
|`*`|星号|可以匹配任意多次，也可能不匹配|
|`+`|加号|至少匹配一次，至多可以任意多次|
|`{min,max}`|区间量词|至少要`min`次，至多`max`次|

- 匹配位置的元字符

|元字符||匹配对象|
|------|------|----|
|`^`|脱字符|匹配一行的开头|
|`$`|美元符|匹配一行的结束|
|`\<`|单词分界符|匹配单词的开始位置|
|`\>`|单词分界符|匹配单词的结束位置|

- 其他元字符

|元字符||匹配对象|
|------|------|----|
|`|`|alternation|匹配任意分隔的表达式|
|`(...)`|括号|限定多选结构的范围，标量助词作用的元素，为反向引用捕获文本|
|`(?:...)`|非捕获型括号|括号内所匹配的文本并不会被捕获而存放|
|`\1,\2`|反向引用|匹配之前的第一，第二组括号里的子表达式匹配的文本|

- 环视

|类型|正则表达式|匹配成功的条件||
|----|---------|----------|--|
|肯定逆序环视|`(?<=...)`|子表达式能匹配左侧文本|JS不支持|
|否定逆序环视|`(?<!...)`|子表达式不能匹配左侧文本|JS不支持|
|肯定顺序环视|`(?=...)`|子表达式能够匹配右侧文本|
|否定顺序环视|`(?!...)`|子表达式不能匹配右侧文本|


以上只是正则表达式的基础，是基于`Perl`的，但是正则的流派很多，并非所有语言都支持以上的规则。

### Javascript正则表达式

创建方式

- 使用一个正则表达式字面量，其由包含在斜杠之间的模式组成
  ```javascript
  const pattern1 = /s$/;

  const pattern2= /^[a-zA-Z]+[0-9]*\W?_$/gi;
  ```
- 调用RegExp对象的构造函数
  ```javascript
  let regex = new RegExp("ab+c");

  let regex = new RegExp(/^[a-zA-Z]+[0-9]*\W?_$, "gi");

  let regex = new RegExp("^[a-zA-Z]+[0-9]*\W?_$", "gi");
  ```
JS扩展字符

|字符|描述|
|---|---|
|`{n}`|`n`为正整数，表示前面字符刚好被匹配`n`次|
|`\w`|	任何ASCⅡ字符组成的单词，等价于[a-zA-Z0-9_]
|`\W`|	任何不是ASCⅡ字符组成的单词，等价于[^a-zA-Z0-9_]
|`\s`|	任何Unicode空白符
|`\S`	|任何非Unicode空白符，注意`\w`和`\S`的不同
|`\d`|任何ASCⅡ数字，等价于[0-9]
|`\D`	|除了ASCⅡ数字之外的任何字符，等价于[^0-9]
|`[\b]`|退格直接量|
|`\b`|	匹配一个单词的边界，简而言之，就是位于字符`\w`和字符`\W`之间的位置，或位于字符`\w`和字符串的开头或结尾之间的位置（但需要注意的是在字符组内`[\b]`匹配的是退格符）
|`\B`|	匹配非单词边界的位置

修饰符
|字符	|匹配|
|-----|----|
|`i`|	执行不区分大小写的匹配
|`g`	|执行一个全局匹配，简而言之，即找到所有的匹配，而不是在找到第一个之后就停止
|`m`	|多行匹配模式，^匹配一行的开头和字符串的开头，$匹配行的结束和字符串的结束
