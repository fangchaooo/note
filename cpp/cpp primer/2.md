# 变量和基本类型

## 基本内置类型

### 算术类型

除了与C相同的基本类型外，增加了

| 类型       | 含义        | 最小尺寸 |
| -------- | --------- | ---- |
| wchar_t  | 宽字符       | 16位  |
| char16_t | Unicode字符 | 16   |
| char32_t | Unicode字符 | 32   |

### 字符和字符串字面值

由但括号引起的一个字符是char型字面值，双引号括起来的零个或多个字符则构成字符串字面值。

```c++
'a' //字符字面值
  
"Hello World" //字符串字面值
```

**指定字面值**：

`u U L u8`

## 变量

### 初始化

- 列表初始化

  ```c++
  int a = {0};   //使用列表初始化且初始化存在信息丢失的风险，则编译器将报错

  long double ld = 3.1415926536;

  int b{ld}, c = {ld};  //错误： 转换未执行，存在丢失信息的危险
  ```

- 默认初始化

  如果定义变量时没有指定**初始值**，则变量被**默认初始化**

  1. 如果是内置类型的变量未被显式初始化，它的值由定义的位置决定。定义于任何函数之外的变量被初始化为0。
  2. 定义于函数内部的内置变量类型将**不被初始化**。

  ```c++
  double a = b = 3.14;  //error: ‘d’ was not declared in this scope
  ```


### 声明和定义

声明使得名字为程序所知，一个文件如果想使用别处定义的名字则必须包含对其的声明。

定义则负责创建与名字关联的实体。

**变量能且只能被定义一次，但可以被多次声明**

```c++
extern int i;  //声明i而非定义i

int j;         //声明并定义j

extern double pi = 3.1415   //定义
```

## 复合类型

### 引用

- 引用必须被初始化，引用必须绑定在一个对象上。
- 引用即别名
- 引用类型必须与其所引用对象的类型一致

### 指针

- 指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期里它可以先后指向不同的对象。
- 指针无须在定义时赋值。和其他内置类型一样，在快作用域 内定义的指针如果没有被初始化，也将拥有一个不确定的值。

指针值：

1. 指向一个对象
2. 指向对象紧邻对象所占空间的下一个位置
3. 空指针，意味着指针没有指向任何对象
4. 无效指针，也就是上述情况之外的其他值

> 建议：初始化所有指针

`void`指针

`void*`是一种特殊的指针类型，可以存放任意对象的地址。

**指向指针的引用**

引用本身不是一个对象，因此不能定义指向引用的指针。但指针是对象，所以存在指针的引用。

### CONST

const对象一旦创建之后不能改变，因此**const对象必须初始化**。

#### const引用

可以把引用绑定到const对象上，就像绑定到其他对象上，我们称之为对**常量的引用**。与普通引用不同的是，对**常量的引用不能用作修改它所绑定的对象**。

初始化常量引用时允许用任意表达式作为初始值，只要该表达式可以转换成引用的类型即可。

#### 指针和const

指向常量的指针不能用于改变其所指对象的值。要想存放常量对象的地址，只能使用指向常量的指针。

```c++
const double pi = 3.14;
doublt *ptr = &pi;  //错误，ptr是一个普通指针
const double *cptr = &pi;  //正确，cptr可以指向一个双精度常量
*cptr = 42;   //错误，不能给*cptr赋值
```

#### const指针

常量指针必须**初始化**，而且一旦初始化完成，它的值就不能改变了。

*在const之前说明指针是一个常量，即不变的是指针本身的值而不是指向的那个值。

### 常量表达式---constexpr

值不会改变并且在编译过程中就能得到计算结果的表达式。

一个constexpr的指针初始值必须是**nullptr/0**，或是存储于某个固定地址中的对象。

在constexpr声明中如果定义了一个指针，限定符constexpr仅对指针有效，与指针所指的对象无关

```c++
const int *p = nullptr;      //p是一个指向整形常量的指针
constexpr int *q = nullptr;  //q是一个指向整数的常量指针
```

## 处理类型

### 类型别名

- typedef
- using

### auto

auto让编译器去推断表达式所属类型，**auto定义的变量必须有初始值**

auto一般会忽略顶层const

### decltype

选择并返回操作数的数据类型。

如果decltype使用的表达式是一个变量，则decltype返回该变量的类型。如果decltype使用的表达式不是一个变量，则decltype返回表达式结果对应的类型。

## 自定义数据结构

struct name{};

## 头文件

```c++
#ifndef NAME_H
#define NAME_H
...
 
#endif
```

