---
title: Java基本程序结构
date: 2016-09-18 22:05:20
categories: 编程
tags: [java]
---
Java的基本语法（与C/C++相对比）
<!-- more -->


 ## 注释
 ``` java
   /**
     * 文档注释
     */

    //单行注释

    /*长篇注释 */
  ```

  ## 数据类型

  **Java没有任何无符号类型**

  * #### 整形

    `java`的整型范围与所在的机器无关

    |类型    |存储需求   |   取值范围|
    |--------|---------|---------|
    |`int`   |    4字节 |-2147483648~2147483647|
    |`short` | 2字节    |-32768~32767|
    |`long`  |8字节     |             |
    |`byte`|   1字节   |-128~127|

    长整型有后缀`L`

    二进制的前缀`0b`
  * #### 浮点类型

    |类型|存储需求|
    |----|----|
    |float|4字节|
    |double|8字节|

    `float`类型后加`f`,默认为'double'.

    浮点数的计算遵循IEEE754规则（参考csapp第一章）。

    特殊浮点数：
      * 正无穷大
      * 负无穷大
      * NaN

        一个正整数除以0的结果为正无穷大。计算0/0或者负数的平方根结果为NaN。


  * #### `char`类型

    Java中,char类型用UTF-16编码描述一个代码单元。

      **强烈建议不要在程序中使用char类型，最好将需要处理的字符串用抽象数据类型表示**

  * #### `boolean`类型

    java中整数不能转换为布尔值。
    ``` java
    if(x=0)//不能通过编译
      System.out.println("oo-oo")l;
      ```

## 变量

java中声明一个变量之后，必须用赋值语句对变量进行显式初始化，千万不能使用未使用初始化的变量。
**java中不区分变量的额定义和声明。**

`final`指示常量。

**`++,--`运算符解析**

> **在c/c++中**
> ```c
> int i=0,j=0;
> j=++i+++i+i++；
> ```
> 这种代码常见于各类“谭书”中，经常出现在各种新手论坛中或某计算
机考试中，这样的问题实在是不应该浪费时间，因为它们几乎都是“未指明的行为”或“由实现定义的行为”。另一方面，程序的错误或Bugs，通常是由于“未定义的行为”。
> 使用了未定义行为的程序都是错误的，即使程序能够运行，也只是巧合。未定义行为源于编译器不能检测到的程序错误或太麻烦以至无法检测的错误。
不幸的是，含有未定义行为的程序在有些环境或编译器中可以正确执行，但并不能保证同一程序在不同编译器中甚至在当前编译器的后继版本中会继续正确运行，也不能保证程序在一组输入上可以正确运行且在另一组输入上也能正确运行。
 程序不应该依赖未定义行为。
>
>**在Java中**


## 数值转换

* 两个操作数有一个是double，另一个也会转换为double。
* 否则，其中一个是float，另一个也将转换为flaot。
* 否则，其中一个是long，另一个也将转换为long。
* 否则，两个都将转换为int。

## 字符串

java字符串就是Unicode字符序列。

* #### 子串
  使用`substring`方法可以从一个大的字符串中提取一个子串。
  ```java
  String greeting = "hello";
  String s = greeting.substring(0,3);//s=hel
  ```
* #### 拼接
  java使用`+`拼接字符串。(任何一个java对象都可以转化为字符串)

* #### 不可变字符串

  String类没有提供可以修改字符串的方法。但是java可以用重新创建字符串的方法进行修改。

  ```java
  String str = "hello";
  str = str.substring(0,3)+"p!";//str="help!"
  ```
  在Java切忌认为String是字符数组，事实上，java的String更像是char*指针。

   ```c
   char* str = "hello";
   char* temp = malloc(6);//字符串末尾还有'\0'
   strncpy(temp,str,3);
   strnpy(temp+3,"p!",3);
   str = temp;
   ```


* #### 检测字符串相等
  `s.equals(t);`

  不区分大小写的是`equalsIgnoreCase`.

  `==`只能比较字符串是否在同一个内存中。

  ``""``是长度为0的字符串

* #### 代码点和代码单元
  java字符串由char序列组成，char数据类型是一个采用UTF-16编码表示Unicode代码点的代码单元。

  而大多数的常用Unicode字符使用一个代码单元就可以表示，而辅助字符却需要两个。
  >学过《深入理解计算机系统》（csapp）这些问题都是很简单的。
  >
  >字符是抽象的最小文本单位。它没有固定的形状（可能是一个字形），而且没有值。“A”是一个字符，“€”（德国、法国和许多其他欧洲国家通用货币的标志）也是一个字符。
  >
  >  字符集是字符的集合。例如，汉字字符是中国人最先发明的字符，在中文、日文、韩文和越南文的书写中使用。
  >
  >  编码字符集是一个字符集，它为每一个字符分配一个唯一数字。Unicode 标准的核心是一个编码字符集，字母“A”的编码为 004116 和字符“€”的编码为20AC16.Unicode 标准始终使用十六进制数字，而且在书写时在前面加上前缀“U+”，所以“A”的编码书写为“U+0041”。
  >
  >  代码点是指可用于编码字符集的数字。编码字符集定义一个有效的代码点范围，但是并不一定将字符分配给所有这些代码点。有效的 Unicode 代码点范围是 U+0000 至 U+10FFFF.Unicode 4.0 将字符分配给一百多万个代码点中的 96，382 代码点。
  >
  >  增补字符是代码点在 U+10000 至 U+10FFFF 范围之间的字符，也就是那些使用原始的 Unicode 的 16 位设计无法表示的字符。从 U+0000 至 U+FFFF 之间的字符集有时候被称为基本多语言面 （BMP）。因此，每一个 Unicode 字符要么属于 BMP，要么属于增补字符。
  >
  >  字符编码方案是从一个或多个编码字符集到一个或多个固定宽度代码单元序列的映射。最常用的代码单元是字节，但是 16 位或 32 位整数也可用于内部处理。UTF-32、UTF-16 和 UTF-8 是 Unicode 标准的编码字符集的字符编码方案。
  >
  >  UTF-32 即将每一个 Unicode 代码点表示为相同值的 32 位整数。很明显，它是内部处理最方便的表达方式，但是，如果作为一般字符串表达方式，则要消耗更多的内存。
  >
  >  UTF-16 使用一个或两个未分配的 16 位代码单元的序列对 Unicode 代码点进行编码。值 U+0000 至 U+FFFF 编码为一个相同值的 16 位单元。增补字符编码为两个代码单元，第一个单元来自于高代理范围（U+D800 至 U+DBFF），第二个单元来自于低代理范围（U+DC00 至 U+DFFF）。这在概念上可能看起来类似于多字节编码，但是其中有一个重要区别：值 U+D800 至 U+DFFF 保留用于 UTF-16；没有这些值分配字符作为代码点。这意味着，对于一个字符串中的每个单独的代码单元，软件可以识别是否该代码单元表示某个单单元字符，或者是 否该代码单元是某个双单元字符的第一个或第二单元。这相当于某些传统的多字节字符编码来说是一个显著的改进，在传统的多字节字符编码中，字节值 0x41 既可能表示字母“A”，也可能是一个双字节字符的第二个字节。
  >
  >  UTF-8 使用一至四个字节的序列对编码 Unicode 代码点进行编码。U+0000 至 U+007F 使用一个字节编码，U+0080 至 U+07FF 使用两个字节，U+0800 至 U+FFFF 使用三个字节，而 U+10000 至 U+10FFFF 使用四个字节。UTF-8 设计原理为：字节值 0x00 至 0x7F 始终表示代码点 U+0000 至 U+007F（Basic Latin 字符子集，它对应 ASCII 字符集）。这些字节值永远不会表示其他代码点，这一特性使 UTF-8 可以很方便地在软件中将特殊的含义赋予某些 ASCII 字符。
  >
  > | Unicode代码点 | U+0041| U+00DF| U+6771| U+10400
  > |--------------|---------|----|-------|-----|
  > |表示字形    |
  > |UTF-32代码单元|00000041|000000DF|00006771|00010400|
  > |UTF-16代码单元|0041|00DF|6771|D801 DC00|
  > |UTF-8代码单元|41|C3 9F|E6 9D B1|F0 90 90 80|

  `length`方法得到的是采用UTF-16编码表示的给定字符串所需要的代码单元数量。
  ```java
  String greeting = "hello";
  int n = greeting.length();//5
  ```
  而要得到实际的长度，即代码点数量，需要调用：
  ```java
  int cpCount = greeting.codePointCount(0,greeting.length())`
  ```
* ####构建字符串

  在前面采用的连接重建字符串的方法是非常慢，这一点不罗曼缇克。
  使用`StringBuilder`就好了。

  `StringBuilder builder = new StringBuilder()`

  添加时用`append`，构建新的时候用`toString`就好。

  这部分面试的时候会经常问，所以后面会在构造器深入记录。

## 输入输出

* #### 读取输入
  ```java
  Scanner in = new Scanner(System.in);
  String name = in.nextLine();//读取一行
  String word = in.next();//读取一个单词
  String number = in.nextInt();//读取一个int数
  ```
* #### 格式化输出

  与**c**基本相同

* #### 文件输入输出
  读取文件要构造一个`Scanner`对象。

  `Scanner in = new Scanner(Paths.get(""))`

  写入文件要构造`PrintWrite`对象。

  `PrintWrite in = new PrintWrite("")`
## 控制流程
  与`c`相同，多了`for each`
## 数组
  创建数组：
  ```java
  int[] a = new int[100];
  String[] a = new String[100];
  ```
  创建一个数字数组时，所有元素初始化为`0`；创建一个boolean数组时，所有对象初始化为`false`;创建一个对象数组，则所有元素会被初始化为`null`。
* #### for each
  格式：

  `for (variable : collection) statement`

  表示为每一个变量是暂存于集合中的变量，这个集合表达式必须是一个数组或者实现了`Iterable`的接口。

* #### 数组初始化
  ```java
  int[] ArrayInt = {1,2,3,5}；//创建数组对象并同时初始化
  OtherArrayInt = new int[] {1,2,3,5}//相当于int[] ArrayInt = {1,2,3,5}；OtherArrayInt=ArrayInt；
  new elementType[0];//创建一个长度为0的数组
  ```
* #### 多维数组
  ```java
  int[][] Array = {
    {1,2},
    {1,24},
    {7,8,}
  }
  ```
* #### 不规则数组
  ```java
  int NMAX = 10;
  int[][] odds = new int [NMAX+1][];
  for(int n = 0;n<= NMAX;n++)
    odds[n] = new int[n+1];
  for(int n =0;n<odds.length;n++)
    for(int k = 0; k<odds[n].length;k++)
    {
      int lotteryOdds = 1;
      for(int i =1;i<=k;i++)
        lotteryOdds = lotteryOdds*(n-i+1)/i;
      odds[n][k] = lotteryOdds;
    }
    //compute n*(n-1)*(n-2)*...*(n-k+1)/(1*2*3*...*k)
  ```
